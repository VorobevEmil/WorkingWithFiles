@page "/"
@inject HttpClient httpClient
@using System.Security.Cryptography
@using System.Text
@using WorkingWithFiles.Shared
@using System.Net.Http.Json
@using WorkingWithFiles.Shared.Model


<MudTable Items="@Files" Loading="@loading" Dense="@dense" Hover="@hover" Bordered="@bordered" Striped="@striped" Filter="new Func<FileModel,bool>(FilterFunc)" MultiSelection="true" @bind-SelectedItems="selectedFiles">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Работа с файлами</MudText>
        <MudSpacer />
        <MudTextField @bind-Value="searchString" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
    </ToolBarContent>
    <HeaderContent>
        <MudTh>Название файла</MudTh>
    </HeaderContent>
    <RowTemplate>

        <MudTd DataLabel="FileName">@context.FileName</MudTd>

    </RowTemplate>
    <PagerContent>
        <MudTablePager RowsPerPageString="Строк на странице:" />
    </PagerContent>
</MudTable>

<div class="d-flex flex-wrap mt-4">
    <MudSwitch @bind-Checked="@hover" Color="Color.Primary">Hover</MudSwitch>
    <MudSwitch @bind-Checked="@dense" Color="Color.Secondary">Dense</MudSwitch>
    <MudSwitch @bind-Checked="@striped" Color="Color.Tertiary">Striped</MudSwitch>
    <MudSwitch @bind-Checked="@bordered" Color="Color.Warning">Bordered</MudSwitch>
    <MudSpacer />
    <div style="min-width:200px;">
        <InputFile id="fileInput" OnChange="OnFileSelection" hidden multiple />

        <MudButton HtmlTag="label" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Filled.CloudUpload" for="fileInput" Disabled="isDisabled">Загрузить файлы</MudButton>

        <MudButton OnClick="DeleteFile" Variant="Variant.Filled" StartIcon="@Icons.Filled.Delete" Color="Color.Secondary" Size="Size.Medium" Disabled="isDisabled">Удалить файлы</MudButton>
    </div>
</div>

<MudSpacer />
<div style="min-width:200px;">
    <MudText Inline="true" Class="align-self-center">
        Выбранны файлы:
        @foreach (var file in selectedFiles)
        {
            <span class="">@file.FileName @(new string("\t"))</span>
        }
    </MudText>
</div>

@if (!string.IsNullOrWhiteSpace(message))
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled">@message</MudAlert>
}

@code {
    private string message = string.Empty;
    private bool isDisabled = false;

    private bool loading = true;
    private bool dense = false;
    private bool hover = true;
    private bool striped = false;
    private bool bordered = false;
    private string searchString = string.Empty;
    private HashSet<FileModel> selectedFiles = new HashSet<FileModel>();

    private IEnumerable<FileModel>? Files = new List<FileModel>();

    protected override async Task OnInitializedAsync()
    {
        await LoadFiles();
    }

    private async Task LoadFiles()
    {
        loading = true;

        Files = await httpClient.GetFromJsonAsync<List<FileModel>>("api/Quality/GetFiles/Data");

        loading = false;
        isDisabled = false;
    }


    private bool FilterFunc(FileModel file)
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;

        if (file?.FileName?.Contains(searchString, StringComparison.OrdinalIgnoreCase) ?? false)
            return true;

        return false;
    }

    private async Task DeleteFile()
    {
        isDisabled = true;
        loading = true;

        foreach (var file in selectedFiles)
        {
            await httpClient.PostAsJsonAsync("api/Quality/DeleteFile", file);
        }

        selectedFiles.Clear();

        await LoadFiles();
    }


    List<FileData> fileData = new List<FileData>();
    private async Task OnFileSelection(InputFileChangeEventArgs e)
    {
        isDisabled = true;
        loading = true;
        try
        {
            foreach (IBrowserFile imgFile in e.GetMultipleFiles())
            {

                var buffers = new byte[imgFile.Size];

                await imgFile.OpenReadStream().ReadAsync(buffers);

                fileData.Add(new FileData
                    {
                        Data = buffers,
                        FileName = imgFile.Name
                    });
            }
            await SaveToServer();

        }
        catch (IOException)
        {
            await SetErrorMessage("Превышен максимальный размер файла");
        }
        catch (Exception)
        {
            await SetErrorMessage("Не удалось загрузить файл");
        }

        await LoadFiles();
    }

    private async Task SaveToServer()
    {
        if (fileData.Count > 0)
        {
            var payload = new SaveFile { Files = fileData };
            var response = await httpClient.PostAsJsonAsync("api/Quality/UploadFile", payload);

            if(response.StatusCode == System.Net.HttpStatusCode.Conflict)
            {
                message = await response.Content.ReadAsStringAsync(); 
            }

            fileData.Clear();
        }
    }

    private async Task SetErrorMessage(string m)
    {
        message = m;
        await Task.Delay(2000);
        message = string.Empty;
    }
}