@page "/"
@inject HttpClient httpClient
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@using System.Security.Cryptography
@using System.Text
@using WorkingWithFiles.Shared
@using System.Net.Http.Json
@using WorkingWithFiles.Shared.Model


<MudTable Items="@Files" Loading="@loading" Hover="true" Filter="new Func<FileModel,bool>(FilterFunc)" MultiSelection="true" @bind-SelectedItems="selectedFiles">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Работа с файлами</MudText>
        <MudSpacer />
        <MudTextField @bind-Value="searchString" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
    </ToolBarContent>
    <HeaderContent>
        <MudTh>Название файла</MudTh>
        <MudTh></MudTh>
    </HeaderContent>
    <RowTemplate>

        <MudTd DataLabel="FileName">@context.FileName</MudTd>

        <MudTd Class="d-flex justify-end">
            <MudButton OnClick="(() => DownloadFile(context))" Variant="Variant.Filled" StartIcon="@Icons.Filled.Download" Color="Color.Success" Size="Size.Small" Disabled="isDisabled">Скачать файл</MudButton>
        </MudTd>

    </RowTemplate>
    <PagerContent>
        <MudTablePager RowsPerPageString="Строк на странице:" />
    </PagerContent>
</MudTable>

<div class="d-flex flex-wrap mt-4">
    <MudSpacer />
    <div style="min-width:200px;">
        <InputFile id="fileInput" OnChange="OnFileSelection" hidden multiple />

        <MudButton HtmlTag="label" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Filled.CloudUpload" for="fileInput" Disabled="isDisabled">Загрузить файлы</MudButton>

        <MudButton OnClick="DeleteFile" Variant="Variant.Filled" StartIcon="@Icons.Filled.Delete" Color="Color.Secondary" Size="Size.Medium" Disabled="isDisabled">Удалить файлы</MudButton>
    </div>
</div>

<MudSpacer />
<div style="min-width:200px;">
    <MudText Inline="true" Class="align-self-center">
        Выбранны файлы:
        @foreach (var file in selectedFiles)
        {
            <span class="">@file.FileName @(new string("\t"))</span>
        }
    </MudText>
</div>

@code {
    private bool isDisabled = false;
    private bool loading = true;

    private string searchString = string.Empty;
    private HashSet<FileModel> selectedFiles = new HashSet<FileModel>();

    private IEnumerable<FileModel>? Files = new List<FileModel>();

    protected override async Task OnInitializedAsync()
    {
        await LoadFiles();
    }

    private async Task LoadFiles()
    {
        loading = true;

        Files = await httpClient.GetFromJsonAsync<List<FileModel>>("api/Quality/GetFiles/Data");

        loading = false;
        isDisabled = false;
    }


    private bool FilterFunc(FileModel file)
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;

        if (file?.FileName?.Contains(searchString, StringComparison.OrdinalIgnoreCase) ?? false)
            return true;

        return false;
    }

    [Inject] private IDialogService DialogService { get; set; }

    private async Task DeleteFile()
    {
        bool? result = await DialogService.ShowMessageBox(
            "Внимание",
            "Вы действительно хотите удалить эти файлы? Этот процесс нельзя отменить.",
            yesText: "Удалить!", cancelText: "Отмена");

        if (result == true)
        {
            isDisabled = true;
            loading = true;

            foreach (var file in selectedFiles)
            {
                await httpClient.PostAsJsonAsync("api/Quality/DeleteFile", file);
            }

            selectedFiles.Clear();
            await LoadFiles();
        }

    }


    List<FileData> fileData = new List<FileData>();
    private async Task OnFileSelection(InputFileChangeEventArgs e)
    {
        isDisabled = true;
        loading = true;
        try
        {
            foreach (IBrowserFile imgFile in e.GetMultipleFiles())
            {

                var buffers = new byte[imgFile.Size];

                await imgFile.OpenReadStream().ReadAsync(buffers);

                fileData.Add(new FileData
                    {
                        Data = buffers,
                        FileName = imgFile.Name
                    });
            }
            await SaveToServer();

        }
        catch (IOException)
        {
            Snackbar.Add("Превышен максимальный размер файла", Severity.Warning);
        }
        catch (Exception)
        {
            Snackbar.Add("Не удалось загрузить файл", Severity.Warning);
        }

        await LoadFiles();
    }

    private async Task SaveToServer()
    {
        if (fileData.Count > 0)
        {

            var payload = new SaveFile { Files = fileData };
            var response = await httpClient.PostAsJsonAsync("api/Quality/UploadFile", payload);

            if (response.StatusCode == System.Net.HttpStatusCode.Conflict)
            {
                Snackbar.Add(await response.Content.ReadAsStringAsync(), Severity.Warning);
            }

            fileData.Clear();
        }
    }

    private async Task DownloadFile(FileModel file)
    {
        await JSRuntime.InvokeAsync<string>("open", $"api/Quality/DownloadFile/{Cripto.EncodeDecrypt(file.FullName)}", "_blank");
    }
}